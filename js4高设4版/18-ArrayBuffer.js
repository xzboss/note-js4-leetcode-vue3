
// const buffer = new ArrayBuffer(8) // 创建一个 8 字节第缓冲区
// // buffer: ArrayBuffer {
// //   [Uint8Contents]: <00 00 00 00 00 00 00 00>, // 这里以十六进制显示，每两位代表8位二进制
// //   byteLength: 8
// // }
// const view = new Int16Array(buffer) // 创建 buffer 的视图，Int16Array 标识以 16 位为一项
// // view: [0, 0, 0, 0]
// // 视图构造函数有 Ui/Int8/16/32Array, Float32Array...

// const view2 = new Int16Array(8) // 等效于上两式
// const view3 = new Int16Array(8, 1, 1) // 等效与上式
// const view4 = new Int16Array([1, 2, 3]) // 创建 6 字节缓冲区，并创建视图

// // 其实 Int16Array 与他的实例几乎可以和 Array 及其实例一样使用
// // 除了 concat, splice, pop, push, shift, unshift
// // 提供两种新方法 set, subarray

// const v1 = new Int8Array(8) // [0, 0, 0, 0, 0, 0, 0, 0]
// const v2 = new Int8Array([1, 2, 3, 4]) // [1, 2, 3, 4]
// v1.set(v2, 0) // 第二个参数为起始下标
// console.log(v1) // [1, 2, 3, 4, 0, 0, 0, 0]
// // 超出报错
// // subarray 与 slice 类似不过更加高效

// const v = new Int8Array(6) // [0, 0, 0, 0] 每项范围 -128~127
// v[0] = -129 // 1000 0001 => 0111 1110 => 0111 1111 => 127
// v[1] = -8   // 0000 0100 => -8 （没有超出，自动加-）1111 1100 -248
// v[2] = 128  // 1000 0000 => 0111 1111 => 1000 0000 => -128
// v[3] = 256  //10000 0000 =>01111 1111 =>10000 0000 => 0
// v[4] = -246 // 1111 0110 => 0000 1001 => 0000 1010 => 10
// v[5] = -257 //10000 0001 =>01111 1110 =>01111 1111 => -1
// console.log(v,(129).toString(2)) // [ 127, -8, -128, 0, 10, 4 ]

// // 正数补码就是本身，不需要取反加一
// // 负数补码才取反加一
// // 如果有符号 Int8Array 不管我们赋何值，只要最高位为 1 计算机就会将按取负值的补码方式取补码，否则没有超出的话（也就是第8为及之前没有一位是1），存储时默认第八位为1
// // 如果是无符号比如 Uint8Array, 当赋值为负数的时候，计算机就会将按取负值的补码方式取补码

// // 上溢下溢不会影响相邻项，说了多少位为一项就是多少位


const v = new Int8Array(10) // [0, 0, 0, 0] 每项范围 -128~127
const v2 = new Uint8Array(10) // [0, 0, 0, 0] 每项范围 0~255
// https://blog.csdn.net/kai8wei/article/details/44539223
// 有符号（超出范围补字节），但存的时候只取后8位
v[0] = 0    // 原码：0000 0000 =>（正数原码等于补码）=> 补码：0000 0000（存入计算机）=> console：补码：0000 0000 =>（首位为0补码等于原码）=> 原码：0000 0000 => 有符号读出：0
v[1] = 1    // 原码：0000 0001 =>（正数原码等于补码）=> 补码：0000 0001（存入计算机）=> console：补码：0000 0001 =>（首位为0补码等于原码）=> 原码：0000 0001 => 有符号读出：1
v[2] = 128  //（超出范围补字节）原码：0000 0000 1000 0000 =>（正数原码等于补码）=> 补码：1000 0000（取8位存入计算机）=> console：补码：1000 0000 =>（1000 0000 比较特殊直接等于原码❓）=> 原码：1000 0000 => 有符号读出（只看后8位）：-128
v[3] = 130  //（超出范围补字节）原码：0000 0000 1000 0010 =>（正数原码等于补码）=> 补码：1000 0010（取8位存入计算机）=> console：补码：1000 0010 => 反码：1000 0001=> 原码：1111 1110 => 有符号读出：-126
v[4] = -129 //（超出范围补字节）原码：1000 0000 1000 0001 => 反码：1111 1111 0111 1110 => 补码：1111 1111 0111 1111（存入计算机）=> console：补码：0111 1111 => （首位为0补码等于原码）=> 原码：0111 1111 => 有符号读出：127
v[5] = -1   // 原码：1000 0001 => 反码：1111 1110 => 补码：1111 1111（存入计算机） => console：补码：1111 1111 => 反码：1111 1110 => 原码：1000 0001 => 有符号读出：-1
v[6] = 255  //（超出范围补字节）原码：0000 0000 1111 1111 => （正数原码等于补码）=> 补码：1111 1111（取8位存入计算机）=> console：补码：1111 1111 => 反码：1111 1110 => 原码：1000 0001 => 有符号读出：-1
v[7] = -255 //（超出范围补字节）原码：1000 0000 1111 1111 => 反码：1111 1111 0000 0000=> 补码：0000 0001（取8位存入计算机）=> console：补码：0000 0001 =>（首位为0补码等于原码）=> 原码：0000 0001 => 有符号读出：1
v[8] = 384  //（超出范围补字节）原码：0000 0001 1000 0000 =>（正数原码等于补码）=> 补码：1000 0000（取8位存入计算机）=> console：补码：1000 0000 =>（1000 0000 比较特殊直接等于原码❓）=> 原码：1000 0000 => 有符号读出：-128

// 无符号 超出只需截取即可，赋负数存储前取下负数补码，读出按照正数不管符号位直接补码等于原码读出
v2[0] = 0    // 0
v2[1] = 1    // 1
v2[2] = 128  // 1
v2[3] = 257  // 原码：0000 0001 0000 0001 => 补码 0000 0001（存入计算机）=> console：补码 0000 0001 => 原码：0000 0001 => 无符号读出：1
v2[4] = -1   // 原码：1000 0001 0000 0001 => 反码：1111 1110 1111 1110 => 补码 1111 1111（取8位存入计算机）=> console：补码 1111 1111 => 原码：1111 1111 => 无符号读出：255
v2[5] = -128 // 原码：1000 0000 1000 0000 => 反码：1111 1111 0111 1111 => 补码 1000 0000（取8位存入计算机）=> console：补码 1000 0000 => 原码：1000 0000 => 无符号读出：128

// 总结：
//存储逻辑相同
//有符号读出看首位是否为 0 或 1 或 全为 1000 0000 (也就是位所能表示的最小负数)
//      0 补码等于原码，读出原码
//      1 反转补码后按照有符号，读出原码
//      1000 0000 补码等于原码，读出原码
//
//无符号直接读出